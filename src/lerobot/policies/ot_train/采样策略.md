Ablation Study on Sampling Strategy To assess the effectiveness of our sampling strategy, we compare the full method against a variant (denoted as Ours w/o Sampler) that does not apply any trajectory-level
  sampling. In this baseline, source and target data are randomly sampled across trajectories and time steps, with no coordination. We also include an oracle variant (denoted as UOT-Oracle), which constructs
  perfectly paired batches—each state is observed in both the source and target domains to ensure that batch data originates from the same underlying states. We evaluate policy performance on the Stack task under
  the Viewpoint1-Point variation, with results shown in Fig. 9. Temporal-aware strategy improves pairing quality and downstream performance. The oracle baseline demonstrates that, given perfectly aligned data,
  unbalanced OT loss significantly enhances generalization by enabling the encoder to learn domain-invariant representations. In contrast, the no-sampling variant (Ours w/o Sampler) exhibits poor generalization
  in the Target-OOD setting. This degradation likely stems from the low probability of encountering aligned state pairs in minibatches—especially problematic in long-horizon tasks, where uncoordinated sampling
  rarely produces temporally aligned data. 这个思想在ot-sim2real有没有体现? 帮我找出代码证据
  
有，而且是核心实现的一部分。下面是直接的代码证据，分别对应你说的三点：时间感知的轨迹级采样、去掉采样的变体，以及不平衡 OT 的损失与“近似 oracle”的设置。同时，我们在 LeRobot 侧对齐了 ot-sim2real 的“加权采样”做法：BC 主数据与 OT 源数据按权重混采（参考 robomimic MetaDataset）。

  - 时间感知的轨迹级配对（DTW 对齐 + 时窗采样）
      - 读取 DTW 的 pair_info，并按 DTW 距离做源轨迹的加权抽样（越近权重越大）：robomimic/utils/ot_dataset.py:214、robomimic/utils/ot_dataset.py:231
      - 为每个 target 轨迹和时间步，取出与之 DTW 对齐的 source 索引列表，再在这个附近做窗口采样（保证时间对齐）：robomimic/utils/ot_dataset.py:468、robomimic/utils/ot_dataset.py:471、robomimic/utils/
        ot_dataset.py:473、robomimic/utils/ot_dataset.py:475
      - 具体选择哪个源轨迹也按上面的权重分布进行抽样：robomimic/utils/ot_dataset.py:464、robomimic/utils/ot_dataset.py:465
      - 权重函数（将 DTW 距离转成采样权）：robomimic/utils/ot_dataset.py:21
      - 训练脚本实际构建这个 OT 数据集并传入模型：robomimic/scripts/ot_sim2real/ot_train.py:53
  - 去掉采样的变体（“Ours w/o Sampler”的思路）
      - 数据集里提供了直接“打散时间对齐”的开关 no_window：若开启，则源时间步完全在全轨迹范围内随机采样，不再围绕对齐点取窗口（无时间协调）：robomimic/utils/ot_dataset.py:478
      - 生成实验配置里，针对 MMD/消融会把 sharpness=0.0（使不同源轨迹权重近乎均匀）、no_window=True（无时间对齐窗口）组合使用，从而接近“跨轨迹、跨时间随机”的无协调抽样：robomimic/scripts/ot_sim2real/
        generate_exp_configs.py:146
      - 训练端把 no_window 透传给数据集：robomimic/scripts/ot_sim2real/ot_train.py:50、robomimic/scripts/ot_sim2real/ot_train.py:59
  - 不平衡 OT 损失（UOT）与“oracle”相关设定
      - 代价矩阵由“编码特征距离 + 标签距离”加权得到，随后用不平衡 Sinkhorn（带 tau1, tau2 质量正则）解耦合 π：robomimic/algo/diffusion_policy_ot.py:205、robomimic/algo/diffusion_policy_ot.py:217、robomimic/algo/
        diffusion_policy_ot.py:219、robomimic/algo/diffusion_policy_ot.py:230、robomimic/algo/diffusion_policy_ot.py:233
      - 配置中明确暴露了不平衡 OT 的超参（含 tau1, tau2、权重等）：robomimic/config/diffusion_policy_ot_config.py:71、robomimic/config/diffusion_policy_ot_config.py:74、robomimic/config/
        diffusion_policy_ot_config.py:75、robomimic/config/diffusion_policy_ot_config.py:76
      - 训练时将 OT 损失与 BC 噪声回归损失共同优化，从而推动“编码器学习域不变表征”：robomimic/algo/diffusion_policy_ot.py:239、robomimic/algo/diffusion_policy_ot.py:265
      - 近似 “Oracle” 的实现思路：代码里提供了一个 heuristic 选项，会向 UOT 解引入对角先验（鼓励一一配对），相当于在小批量内偏向“完美配对”的耦合形态：robomimic/algo/diffusion_policy_ot.py:222、robomimic/algo/
        diffusion_policy_ot.py:225。严格意义的“UOT-Oracle（每个状态在两域都被观测）”并没有单独命名的脚本，但配合时间对齐采样（上面的 DTW+窗口）以及该对角先验，就能接近你描述的“完美配对批”的效果；若确需“真实的同一
        状态双域观测”，可以通过构造相应的 pair_info 或数据源来实现。

  一句话小结：ot-sim2real 里明确实现了“时间感知的轨迹级采样（DTW+时间窗口）”和“去掉采样的随机变体（no_window + 均匀权重）”，并在训练中采用不平衡 OT（含 tau1/tau2）与 BC 联合优化，符合你提到的消融思想。

对齐实现（LeRobot）：

- 目标：复现 robomimic MetaDataset 的“按数据源权重的混合采样”，并支持“按数据集大小归一化”的选项。
- 入口与配置：
  - 训练脚本：src/lerobot/scripts/lerobot_train.py 中，当 `cfg.ot.enable` 且 `cfg.ot.bc_src_weight` 非空时，会将主数据集（target）与源数据集（src）拼成 `ConcatDataset`，再用 `WeightedRandomSampler` 进行混采。
  - 配置项新增（src/lerobot/configs/default.py::OTConfig）：
    - `bc_src_weight`：源数据占比（如 0.8 表示 80% 样本来自源域）。未设置则退化为旧的“二路 DataLoader 拼 batch”的逻辑。
    - `normalize_bc_weights_by_ds_size`：是否按数据集大小做权重归一化（对应 robomimic 的 `normalize_weights_by_ds_size`）。
  - 示例：src/lerobot/scripts/train_config/act_fr3_ot_99_20_baseline.json 设置 `"bc_src_weight": 0.8, "normalize_bc_weights_by_ds_size": true`。
- 具体逻辑：
  - 先各自按 episode 边界构造有效样本掩码（可选：与 EpisodeAwareSampler 对齐的 `drop_n_last_frames`）。
  - 若启用“按大小归一化”，则将 `bc_src_weight` 与 `1 - bc_src_weight` 的概率质量平均分配到各自有效样本上；否则直接给定每个样本相同的原始数据源权。
  - 拼接得到 `[target; src]` 的 per-sample 权重向量，交给 `WeightedRandomSampler(replacement=True)`，从而在一个 DataLoader 中实现跨数据源的加权抽样。

注意：
- 该实现与 ot-sim2real 一致地在 DataLoader 级别实现“加权混采”，从而简化上层训练循环；同时保留了旧的“分路采样+batch 拼接”的代码路径作为回退。
- OT 配对对齐仍由 `make_ot_dataloader` 与 `LeRobotOTPairDataset` 提供（窗口、sharpness、no_window 等保持不变）。


- src_paired → 源域（rgb）且“配对”的数据，用作 OT 源端，同时也进 BC 混合数据集（config/square_cam_pose/square_cam_pose_ot-sim2real.json:41–47）。
- src_unpaired → 源域（rgb）但“不配对”的数据，仅用于 BC 混合，不参与 OT（config/square_cam_pose/square_cam_pose_ot-sim2real.json:49–55）。
- target_paired → 目标域（cam_pose）且“配对”的数据，用作 OT 目标端，同时也少量进 BC（demo_limit=10，weight=0.1）（config/square_cam_pose/square_cam_pose_ot-sim2real.json:56–62）。
- target_unpaired → 目标域（cam_pose）但“不配对”的数据，当前 weight=0 未使用（config/square_cam_pose/square_cam_pose_ot-sim2real.json:63–69）。
