Ablation Study on Sampling Strategy To assess the effectiveness of our sampling strategy, we compare the full method against a variant (denoted as Ours w/o Sampler) that does not apply any trajectory-level
  sampling. In this baseline, source and target data are randomly sampled across trajectories and time steps, with no coordination. We also include an oracle variant (denoted as UOT-Oracle), which constructs
  perfectly paired batches—each state is observed in both the source and target domains to ensure that batch data originates from the same underlying states. We evaluate policy performance on the Stack task under
  the Viewpoint1-Point variation, with results shown in Fig. 9. Temporal-aware strategy improves pairing quality and downstream performance. The oracle baseline demonstrates that, given perfectly aligned data,
  unbalanced OT loss significantly enhances generalization by enabling the encoder to learn domain-invariant representations. In contrast, the no-sampling variant (Ours w/o Sampler) exhibits poor generalization
  in the Target-OOD setting. This degradation likely stems from the low probability of encountering aligned state pairs in minibatches—especially problematic in long-horizon tasks, where uncoordinated sampling
  rarely produces temporally aligned data. 这个思想在ot-sim2real有没有体现? 帮我找出代码证据
  
有，而且是核心实现的一部分。下面是直接的代码证据，分别对应你说的三点：时间感知的轨迹级采样、去掉采样的变体，以及不平衡 OT 的损失与“近似 oracle”的设置。

  - 时间感知的轨迹级配对（DTW 对齐 + 时窗采样）
      - 读取 DTW 的 pair_info，并按 DTW 距离做源轨迹的加权抽样（越近权重越大）：robomimic/utils/ot_dataset.py:214、robomimic/utils/ot_dataset.py:231
      - 为每个 target 轨迹和时间步，取出与之 DTW 对齐的 source 索引列表，再在这个附近做窗口采样（保证时间对齐）：robomimic/utils/ot_dataset.py:468、robomimic/utils/ot_dataset.py:471、robomimic/utils/
        ot_dataset.py:473、robomimic/utils/ot_dataset.py:475
      - 具体选择哪个源轨迹也按上面的权重分布进行抽样：robomimic/utils/ot_dataset.py:464、robomimic/utils/ot_dataset.py:465
      - 权重函数（将 DTW 距离转成采样权）：robomimic/utils/ot_dataset.py:21
      - 训练脚本实际构建这个 OT 数据集并传入模型：robomimic/scripts/ot_sim2real/ot_train.py:53
  - 去掉采样的变体（“Ours w/o Sampler”的思路）
      - 数据集里提供了直接“打散时间对齐”的开关 no_window：若开启，则源时间步完全在全轨迹范围内随机采样，不再围绕对齐点取窗口（无时间协调）：robomimic/utils/ot_dataset.py:478
      - 生成实验配置里，针对 MMD/消融会把 sharpness=0.0（使不同源轨迹权重近乎均匀）、no_window=True（无时间对齐窗口）组合使用，从而接近“跨轨迹、跨时间随机”的无协调抽样：robomimic/scripts/ot_sim2real/
        generate_exp_configs.py:146
      - 训练端把 no_window 透传给数据集：robomimic/scripts/ot_sim2real/ot_train.py:50、robomimic/scripts/ot_sim2real/ot_train.py:59
  - 不平衡 OT 损失（UOT）与“oracle”相关设定
      - 代价矩阵由“编码特征距离 + 标签距离”加权得到，随后用不平衡 Sinkhorn（带 tau1, tau2 质量正则）解耦合 π：robomimic/algo/diffusion_policy_ot.py:205、robomimic/algo/diffusion_policy_ot.py:217、robomimic/algo/
        diffusion_policy_ot.py:219、robomimic/algo/diffusion_policy_ot.py:230、robomimic/algo/diffusion_policy_ot.py:233
      - 配置中明确暴露了不平衡 OT 的超参（含 tau1, tau2、权重等）：robomimic/config/diffusion_policy_ot_config.py:71、robomimic/config/diffusion_policy_ot_config.py:74、robomimic/config/
        diffusion_policy_ot_config.py:75、robomimic/config/diffusion_policy_ot_config.py:76
      - 训练时将 OT 损失与 BC 噪声回归损失共同优化，从而推动“编码器学习域不变表征”：robomimic/algo/diffusion_policy_ot.py:239、robomimic/algo/diffusion_policy_ot.py:265
      - 近似 “Oracle” 的实现思路：代码里提供了一个 heuristic 选项，会向 UOT 解引入对角先验（鼓励一一配对），相当于在小批量内偏向“完美配对”的耦合形态：robomimic/algo/diffusion_policy_ot.py:222、robomimic/algo/
        diffusion_policy_ot.py:225。严格意义的“UOT-Oracle（每个状态在两域都被观测）”并没有单独命名的脚本，但配合时间对齐采样（上面的 DTW+窗口）以及该对角先验，就能接近你描述的“完美配对批”的效果；若确需“真实的同一
        状态双域观测”，可以通过构造相应的 pair_info 或数据源来实现。

  一句话小结：ot-sim2real 里明确实现了“时间感知的轨迹级采样（DTW+时间窗口）”和“去掉采样的随机变体（no_window + 均匀权重）”，并在训练中采用不平衡 OT（含 tau1/tau2）与 BC 联合优化，符合你提到的消融思想。